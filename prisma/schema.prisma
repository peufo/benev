generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

model User {
  id String @id @unique

  email     String  @unique
  phone     String?
  firstName String
  lastName  String

  birthday DateTime?
  street   String?
  zipCode  String?
  city     String?

  tokens          Token[]
  isEmailVerified Boolean @default(false)

  avatarId          String? @unique
  avatar            Media?  @relation(name: "avatar", references: [id], fields: [avatarId], onDelete: SetNull)
  avatarPlaceholder String  @default("") // remove default value after migration

  wantsNotification Boolean @default(true)

  members Member[]
  events  Event[] // ownerOf

  auth_session Session[]
  auth_key     Key[]
  medias       Media[]
  bans         Ban[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Session {
  id             String @id @unique
  user_id        String
  active_expires BigInt
  idle_expires   BigInt
  user           User   @relation(references: [id], fields: [user_id], onDelete: Cascade)

  @@index([user_id])
}

model Key {
  id              String  @id @unique
  hashed_password String?
  user_id         String
  user            User    @relation(references: [id], fields: [user_id], onDelete: Cascade)

  @@index([user_id])
}

model Token {
  id      String    @id
  type    TokenType
  expires BigInt
  userId  String
  user    User      @relation(references: [id], fields: [userId], onDelete: Cascade)
}

enum TokenType {
  emailVerification
  passwordReset
}

model Event {
  id          String  @id @unique
  name        String  @unique
  ownerId     String
  owner       User    @relation(references: [id], fields: [ownerId], onDelete: Cascade)
  date        String?
  description String?
  logo        String?
  web         String?
  email       String?
  phone       String?
  address     String?
  timezone    Int     @default(-120)

  teams        Team[]
  pages        Page[]
  members      Member[]
  memberFields Field[]
  bans         Ban[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Ban {
  id        String   @id @default(cuid())
  eventId   String
  event     Event    @relation(fields: [eventId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([eventId, userId])
}

model Field {
  id              String       @id @default(cuid())
  eventId         String
  event           Event        @relation(references: [id], fields: [eventId], onDelete: Cascade, onUpdate: Cascade)
  type            FieldType
  name            String
  label           String?
  position        Int          @default(0)
  memberCanWrite  Boolean
  memberCanRead   Boolean
  allCombinations Boolean      @default(false)
  required        Boolean      @default(false)
  description     String?
  options         String?      @db.Text()
  values          FieldValue[]
  createdAt       DateTime     @default(now())
  updatedAt       DateTime     @updatedAt

  @@unique([eventId, name])
}

enum FieldType {
  string
  textarea
  number
  boolean
  select
  multiselect
}

model FieldValue {
  id        String   @id @default(cuid())
  fieldId   String
  field     Field    @relation(references: [id], fields: [fieldId], onDelete: Cascade)
  memberId  String
  member    Member   @relation(references: [id], fields: [memberId], onDelete: Cascade)
  value     String   @db.Text()
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([fieldId, memberId])
}

model Member {
  id String @id @default(cuid())

  isAdmin          Boolean @default(false)
  isValidedByEvent Boolean @default(false)
  isValidedByUser  Boolean @default(false)

  userId  String
  user    User   @relation(references: [id], fields: [userId], onDelete: Cascade)
  eventId String
  event   Event  @relation(references: [id], fields: [eventId], onDelete: Cascade, onUpdate: Cascade)

  subscribes Subscribe[]
  leaderOf   Team[]
  profile    FieldValue[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, eventId])
}

model Page {
  id String @id @default(cuid())

  eventId String
  event   Event  @relation(references: [id], fields: [eventId], onDelete: Cascade, onUpdate: Cascade)

  title   String
  path    String  @default("")
  isIndex Boolean @default(false)
  content String  @db.Text

  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  @@unique([eventId, path])
}

model Team {
  id String @id @default(cuid())

  name        String
  description String?  @db.Text
  leaders     Member[]

  eventId String
  event   Event    @relation(references: [id], fields: [eventId], onDelete: Cascade, onUpdate: Cascade)
  periods Period[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([name, eventId])
}

model Period {
  id String @id @default(cuid())

  start        DateTime
  end          DateTime
  maxSubscribe Int         @default(1)
  teamId       String
  team         Team        @relation(references: [id], fields: [teamId], onDelete: Cascade)
  subscribes   Subscribe[]
  createdAt    DateTime    @default(now())
  updatedAt    DateTime    @updatedAt
}

model Subscribe {
  id String @id @default(cuid())

  state     SubscribeState     @default(request)
  createdBy SubscribeCreatedBy @default(user)

  periodId String
  period   Period @relation(references: [id], fields: [periodId], onDelete: Cascade)

  memberId String
  member   Member @relation(references: [id], fields: [memberId], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([memberId, periodId])
}

enum SubscribeCreatedBy {
  user
  leader
}

enum SubscribeState {
  request
  accepted
  denied
  cancelled
}

model Media {
  id String @id @default(uuid())

  name        String
  avatarOf    User?    @relation(name: "avatar")
  createdById String
  createdBy   User     @relation(references: [id], fields: [createdById], onDelete: Cascade)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}
